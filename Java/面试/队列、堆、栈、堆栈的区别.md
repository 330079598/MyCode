## 栈

什么是栈？这是计算机内存的特定区域，它存储每个函数创建的临时变量（包括main() 函数）。栈使用“LIFO”数据结构，由CPU管理和优化。每当函数声明一个新变量，它就会被推入栈。当函数退出时，所有被该函数推入栈的变量会被释放（这代表，它们已经被删除）。一旦栈的变量释放，此内存区可以被其他栈变量使用。

使用栈保存变量的优点：CPU帮你管理内存。你不需要手动分配和释放。更重要的是，CPU可以高效的组织内存，读写栈变量会非常快。

理解栈的关键 ：当函数退出时，它推入栈的所有变量会被弹出（永远丢失）。栈变量本质是局部的。这涉及到我们之前了解的 变量作用域 或 局部和全局变量。在C语言编程通常会遇到此类BUG：从函数外部企图读取函数内部的变量（在函数退出之后）。

栈另一个需要注意的特征是：保存在栈的变量是有大小限制的。堆的情况却不一样。

栈的总结：

- 栈的增长和缩容发生在函数推入和弹出局部变量时
- 不需要你自己管理内存，变量会自动分配和释放
- 栈有大小限制
- 栈变量仅存在于创建它们的函数运行的时候

## 堆

堆是计算机的内存区，它不会帮你自动管理，也不由CPU管理。堆有更大的空间。你需要使用 C语言内置函数malloc()和 calloc() 分配内存到堆。当不再使用这块内存时，你负责使用free()进行释放。如果没做这步，你的程序会发生内存泄露。堆上的内存仍然被占用（不能被其他进程使用）。正如我们在调试中看到的，用 valgrind工具，帮助检测内存泄漏。

和栈不一样，堆没有大小限制（除了物理内存限制）。堆的读写稍微比较慢，因为必须使用指针访问堆上的内存。

和栈不一样，其他函数和你程序上的任何地方都可以访问堆上创建的变量。堆本质是全局的。

## 栈和堆的优缺点

### 栈

- 访问非常快
- 不必显式的分配变量
- CPU有效的管理，不会产生内存碎片
- 仅用于局部变量
- 有大小限制（不同操作系统有区别）
- 大小不能被调整

### 堆

- 变量可以全局访问
- 没有内存限制
- （相对的）访问速度比较慢
- 会产生内存碎片
- 需要你分配和释放
- 大小可以通过 realloc() 调整

## 什么时候使用堆

什么时候使用堆？什么时候使用栈？如果你要分配一块大内存和你需要保留这个变变量很长时间，那么你就要分配它们到堆。如果你处理的是相对小的变量，只需要存活在函数使用期间，那么你可以使用栈，它更容易更快。如果你需要可以动态改变大小的变量例如：数据和结构体，那你需要分配它们到堆，用动态内存分配函数 `mallco()` `calloc()` `realloc()`和 `free()`手动管理内存。我们会讨论动态分配数据结构在讨论完指针后。

[原文地址](https://segmentfault.com/a/1190000019400555)

---

# 队列、堆、栈、堆栈

的区别

**堆栈：先进后出（就像放在箱子的衣服，先放进去的后拿出来）** 

**队列：先进先出（就像一条路，有一个入口和一个出口，先进去的就可以先出去）**

　　**进程中每个线程都有自己的堆栈，这是一段线程创建时保留下的地址区域。** 我们的“栈内存”即在此。

　　至于“堆”内存，我个人认为在未用new定义时，堆应该就是未“保留”未“提交”的自由空间，new的功能是在这些自由空间中保留（并提交）出一个地址范围。

　　栈(Stack)是操作系统在建立某个进程时或者线程（在支持多线程的操作系统中是线程）为这个线程建立的存储区域，该区域具有FIFO的特性，在编译的时候可以指定需要的Stack的大小。在编程中，例如C/C++中，所有的局部变量都是从栈中分配内存空间，实际上也不是什么分配，只是从栈顶向上用就行，在退出函数的时候，只是修改栈指针就可以把栈中的内容销毁，所以速度最快。 
　　

　　堆（Heap)是应用程序在运行的时候请求操作系统分配给自己内存，一般是申请/给予的过程，C/C++分别用malloc/New请求分配Heap，用free/delete销毁内存。由于从操作系统管理的内存分配所以在分配和销毁时都要占用时间，所以用堆的效率低的多！但是堆的好处是可以做的很大，C/C++对分配的Heap是不初始化的。 
　　　在Java中除了简单类型（int,char等）都是在堆中分配内存，这也是程序慢的一个主要原因。但是跟C/C++不同，Java中分配Heap内存是自动初始化的。在Java中所有的对象（包括int的wrapper Integer）都是在堆中分配的，但是这个对象的引用却是在Stack中分配。也就是说在建立一个对象时从两个地方都分配内存，在Heap中分配的内存实际建立这个对象，而在Stack中分配的内存只是一个指向这个堆对象的指针（引用）而已。

 　　堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。{堆是指程序运行是申请的动态内存，而栈只是指一种使用堆的方法(即先进后出)。}

 　　栈是先进后出的，但是于堆而言却没有这个特性，两者都是存放临时数据的地方。 对于堆，我们可以随心所欲的进行增加变量和删除变量，不要遵循什么次序，只要你喜欢。

[原文地址](https://www.cnblogs.com/wuaihua/p/7256872.html#:~:text=%E5%A0%86%E6%98%AF%E5%9C%A8%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C,%E5%AD%98%E6%94%BE%E4%B8%B4%E6%97%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9C%B0%E6%96%B9%E3%80%82)

---

一、预备知识—程序的内存分配 

  一个由C/C++编译的程序占用的内存分为以下几个部分 

  1、栈区（stack）—   由编译器自动分配释放   ，存放函数的参数值，局部变量的值等。其 
  操作方式类似于数据结构中的栈。 

  2、堆区（heap）   —   一般由程序员分配释放，   若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。 

  3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，   未初始化的全局变量和未初始化的静态变量在相邻的另  一块区域。   -   程序结束后由系统释放。 

  4、文字常量区   —常量字符串就是放在这里的。   程序结束后由系统释放 

  5、程序代码区—存放函数体的二进制代码。 

  二、例子程序   

```c
这是一个前辈写的，非常详细   
  //main.cpp   
  int a = 0;   全局初始化区   
  char   *p1;   全局未初始化区   
  main(){   
  int   b;   栈   
  char   s[]   =   "abc";   栈   
  char   *p2;   栈   
  char   *p3   =   "123456";   123456/0在常量区，p3在栈上。 
  static   int   c   =0；   全局（静态）初始化区   
  p1   =   (char   *)malloc(10);   
  p2   =   (char   *)malloc(20);   
  分配得来得10和20字节的区域就在堆区。   
  strcpy(p1,   "123456");   123456/0放在常量区，编译器可能会将它与p3所指向的"123456" 
  优化成一个地方。   
  }   
```

​    二、堆和栈的理论知识   

 2.1申请方式   
  stack:   
  由系统自动分配。   例如，声明在函数中一个局部变量   int   b;   系统自动在栈中为b开辟空间   
  heap:   
  需要程序员自己申请，并指明大小，在c中malloc函数   
  如p1   =   (char   *)malloc(10);   
  在C++中用new运算符   
  如p2   =   new   char[10];   
  但是注意p1、p2本身是在栈中的。   

2.2   申请后系统的响应   
  栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢 出。   
  堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，  会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表 中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的  首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。  另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部 分重新放入空闲链表中。   

  2.3申请大小的限制   
  栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意 思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将 提示overflow。因此，能从栈获得的空间较小。   
  堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储 的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小 受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。   

   2.4申请效率的比较：   
  栈由系统自动分配，速度较快。但程序员是无法控制的。   
  堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.   
  另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是 直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。 
    

  2.5堆和栈中的存储内容   
  栈：   在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可 执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈 的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地 址，也就是主函数中的下一条指令，程序由该点继续运行。   
  堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。   

  2.6存取效率的比较   

```c
  char s1[] = "aaaaaaaaaaaaaaa";   
  char *s2 = "bbbbbbbbbbbbbbbbb";   
  aaaaaaaaaaa是在运行时刻赋值的；   
  而bbbbbbbbbbb是在编译时就确定的；    
  但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。   
  比如：   
  #include   
  void   main(){   
  char   a   =   1;   
  char   c[]   =   "1234567890";   
  char   *p   ="1234567890";   
  a   =   c[1];   
  a   =   p[1];   
  return;   
  }   
  对应的汇编代码   
  10:   a   =   c[1];   
  00401067   8A   4D   F1   mov   cl,byte   ptr   [ebp-0Fh]   
  0040106A   88   4D   FC   mov   byte   ptr   [ebp-4],cl   
  11:   a   =   p[1];   
  0040106D   8B   55   EC   mov   edx,dword   ptr   [ebp-14h]   
  00401070   8A   42   01   mov   al,byte   ptr   [edx+1]   
  00401073   88   45   FC   mov   byte   ptr   [ebp-4],al   
  第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到 
  edx中，再根据edx读取字符，显然慢了。   
```

  2.7小结：   

堆和栈的区别可以用如下的比喻来看出：   

使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就 
  走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自 
  由度小。   

使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由 
  度大。 

