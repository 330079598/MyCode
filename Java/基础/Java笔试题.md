[toc]

#### `Java1.8`版本之前的前提，Java特性中，`abstract class`和`interface`有什么区别？

- 抽象类可以有构造方法，接口中不能有构造方法
- 抽象类中可以有普通成员变量，接口中没有普通成员变量
- 一个类可以实现多个接口，但只能继承一个抽象类

> **抽象类**：
>
> - 关键字`abstract`
> - 子类`extends`继承抽象类，只能单继承
> - 成员变量权限四个`public`、`protect`、`default`、`private`（public 范围最大、protected 可以在包以外的子类、default默认修饰符只能在同一个包下、private只能在当前类。）
> - 抽象方法权限只有`public`、`protected`和`default`三种。
> - 可以包含静态代码块，静态方法
> - 可以有普通方法
> - 继承者如果是全部继承抽象方法就不再是抽象楼，否则仍然是抽象类
>
> **接口**：
>
> - 关键字`interface`
> - 子类`implements`实现接口，实现多个接口
> - 不能有构造器
> - 成员变量默认权限都是`public static final`，接口中声明的成员变量的常量不能被继承
> - 方法默认权限`public`
> - 不可以有静态代码块，可以有静态方法
> - 没有普通方法
> - 下一代只能实现
>
> 接口方法的增加随着版本的更新改变
>
> jdk1.7，接口中只包含抽象方法，使用public abstract修饰
>
> jdk1.8（不包括）之前：接口中不能有静态方法
>
> jdk1.8（包括哦）1.8之后：接口中可以定义静态方法。
>
> 在jdk1.8，接口中加入了默认方法（default修饰，接口的实现类，直接调用或者重写该方法）、静态方法（static修饰，通过接口调用）
>
> 在jdk1.9中，接口中加入了私有方法，使用private修饰，私有方法供接口内的默认方法使用

- 对于局部内部类，只有在方法的局部变量被标记为`final`或局部变量是`effctively final`的，内部类才能使用它们
- 成员内部类位于外部类内部，可以直接调用外部类的所有方法（静态方法和非静态方法）
- 在类方法中调用本类的类方法可以直接调用

> 类方法是属于整个类的，不是每个实例所独有的。
>
> 用static修饰实例方法是属于类的某个对象的。
>
> 类方法在初始化阶段就已经加载到方法区中。对象后来在堆中创建。一个已经存在的怎么可能使用未创建出来的。
>
> 类方法中不能引用对象变量
>
> 类方法中不能调用类的对象方法
>
> 类方法中不能使用super、this关键字
>
> 类方法不能被覆盖
>
> 对象方法可以引用对象变量，也可以引用类变量
>
> 对象方法中可以调用类方法
>
> 对象方法中可以使用super、this关键字。
>
> this关键字的用法
>
> 1. 普通的直接引用，相当于当前对象本身
> 2. 形参与成员名字相同，区分
> 3. 引用本类的构造函数（需要放在构造函数的第一行）
>
> super关键字的用法
>
> 1. 普通的直接引用（引用父类）（相当于指向当前对象的父类的引用）
> 2. 子类中的成员变量或者方法与父类的成员变量或者方法重名时，区分
> 3.  引用父类的构造函数（放在子类构造函数的第一行）
>
> 如果子类重写父类的方法，在new出一个父类对象的子类引用。调用的方法是子类重写的方法，若要调用父类的重名方法需要使用super。







