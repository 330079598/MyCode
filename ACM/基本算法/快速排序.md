**快速排序**（英语：Quicksort），又称**划分交换排序**（partition-exchange sort），简称**快排**，一种[排序算法](https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)，最早由[东尼·霍尔](https://zh.wikipedia.org/wiki/%E6%9D%B1%E5%B0%BC%C2%B7%E9%9C%8D%E7%88%BE)提出。在平均状况下，排序个 n 项目要$O(nlong n)$(大O符号)次比较。在最坏状况下则需要$O(n^2)$次比较，但这种状况并不常见。事实上，快速排序$O(nlong n)$通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。

![](../../Image/Sorting_quicksort_anim.gif)

- 分类：排序算法
- 数据结构：不定
- 最坏时间复杂度：$O(n^2)$
- 最优时间复杂度：$O(n long n)$
- 平均时间复杂度：$O(nlongn)$
- 最坏空间复杂度：根据实现的方式不同而不同

![](../../Image/Partition_example.png)

<center>快速排序采用“分而治之、各个击破”的观念，此为原地（ln-place）分割版本。</center>

快速排序使用*分治法*（Divide and conquer）策略来把一个*序列*（list）分为两个子序列（sub-lists）。

步骤为：

1. 从数列中挑出一个元素，称为“基准”（pivot），
2. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分割结束之后，该基准就处于数列的中间位置。这个称为**分割（partition）**操作。
3. *递归*地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。

递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。