[TOC]

---

---

# 1062 Text Reverse

- Problem Description

```txt
Ignatius likes to write words in reverse way. Given a single line of text which is written by Ignatius, you should reverse all the words and then output them.
```

- Input

```
The input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow.
Each test case contains a single line with several words. There will be at most 1000 characters in a line.
```

- Output

```
For each test case, you should output the text which is processed.
```

- Sample Input

```
3
olleh !dlrow
m'I morf .udh
I ekil .mca
```

- Sample Output

```
hello world!
I'm from hdu.
I like acm.
```

- Hint

```
Remember to use getchar() to read '\n' after the interger T, then you may use gets() to read a line and process it.
```

- 我的理解：如果想用string的话，可能就要用到getline()这个方法，getline()遇到换行符就借书读取操作并返回结果，哪怕是你什么也不输入直接输入换行也是如此。所以要想用getline()这个方法就是在一开始输入的时候使用getchar()将换行符读取了，方式结果得到一个空的string。
- getline()使用：getline(cin,str)   把输入的东西存入str中

方法一：

```c++
g++:如果使用c++的话，编译错误，找不到getline()....
#include<iostream>
#include<stdio.h>
#include<string>
using namespace std;

int main(void)
{
    int t,len,count = 0;
    string str;
    while(cin>>t)
    {
    getchar();//防止空字符串

    for(int i = 0;i < t; i++)
    {
        getline(cin,str);
        len = str.size();
        str[len] =' ';
        for(int j = 0;j <= len;j++)
        {
            if(str[j] != ' ')
                count++;
            else
            {
                for(int k = j-1;k >= j-count;k--)
                {
                    cout<<str[k];
                }
                if(j != len)
                    cout<<" ";
                count = 0;
            }
        }
        cout<<endl;
    }
    }
    return 0;
}   
还是有点看不懂。。。。
```





方法二：

```c++
#include<iostream>
#include<string.h>
#include<stdio.h>
using namespace std;

int main(void)
{
    char word[1005];
    int n;
    scanf("%d",&n);
    while(scanf("%s",word) != EOF)
    {
        for(int i = strlen(word)-1;i>=0;i--)
        {
            putchar(word[i]);
        }
        char c;
        while(c=getchar(),c == ' ' || c == '\t' || c == '\n')
            putchar(c);
        ungetc(c,stdin);
    }
    return 0;
}

```

---

# 2104 Hide Handkerchief(质数)

- Problem Description:

```
The Children’s Day has passed for some days .Has you remembered something happened at your childhood? I remembered I often played a game called hide handkerchief with my friends.
Now I introduce the game to you. Suppose there are N people played the game ,who sit on the ground forming a circle ,everyone owns a box behind them .Also there is a beautiful handkerchief hid in a box which is one of the boxes .
Then Haha(a friend of mine) is called to find the handkerchief. But he has a strange habit. Each time he will search the next box which is separated by M-1 boxes from the current box. For example, there are three boxes named A,B,C, and now Haha is at place of A. now he decide the M if equal to 2, so he will search A first, then he will search the C box, for C is separated by 2-1 = 1 box B from the current box A . Then he will search the box B ,then he will search the box A.
So after three times he establishes that he can find the beautiful handkerchief. Now I will give you N and M, can you tell me that Haha is able to find the handkerchief or not. If he can, you should tell me "YES", else tell me "POOR Haha".

```

- Input:

```
There will be several test cases; each case input contains two integers N and M, which satisfy the relationship: 1<=M<=100000000 and 3<=N<=100000000. When N=-1 and M=-1 means the end of input case, and you should not process the data.
```

- Output:

```
For each input case, you should only the result that Haha can find the handkerchief or not.
```

- Sample Output:

```
YES
```

- 我英语太渣了，虽然能看懂大概是什么意思，就是不理解。。。。
- 有N个人玩丢手绢的游戏，手绢藏在某个人的身后的箱子里，Haha去找这个手绢，但是他是隔M-1隔人去找一次箱子，看到这里我们可以想到求这个两个数的最大公约数是不是1，如果是的，Haha就可以循环找完这些箱子，不然就找不到，陷入死循中。（也可以说求这两个数是不是为互质数）
- [这里是辗转相除法的定义和用法](https://en.wikipedia.org/wiki/Euclidean_algorithm)维基百科上的。
- 辗转相除法又称为广义欧几里得除法，是用来求解两个数的最大公约数的最佳算法之一。
- 算法原理：若a除以b的余数为r，则有(a,b) = (b,r)((a,b)表示a和b的最大公约数)

实现：

```c++
int gcd(int a,int b)
{
if(b==0)return a;
else return gcd(b,a%b);
} //递归法求最大公约数，当最大公约数是1的时候，两个数互质
if(gcd(x,y)==1)那么x,y互质
```

换种写法：

```c++

#include <iostream>
#include <conio.h>
using namespace std;
 
int gcd(int a, int b){
	return b == 0 ? a : gcd(b, a % b);
}
 
int main()
{
	cout << gcd(169, 48) << endl;
	_getch();
	return 0;
}
```

- 如果看的懂题，并且知道了用什么方法，那就容易多了。

```c++
#include<iostream>
using namespace std;

int main(void)
{
    int m,n,temp;//这个用的就是辗转相除法
    while(cin>>m>>n && m != -1 || n != -1)
    {
    while(n != 0)
    {
        temp = n;
        n = m%n;
        m = temp;
    }
    if(m == 1)//这里要用m的值，当初我用的是n，举个列子就明白了。。。
    {
        printf("YES\n");
    }
    else
        printf("POOR Haha\n");
    }
    return 0;
}

```

这里还在网上找了一个我感觉写的挺好的方法，挺巧妙的

```c++
#include<iostream>
using namespace std;

int n,m;
int zz(int a,int b)
{
    return b == 0 ? a : zz(b,a%b);
}
int main(void)
{
    while(cin>>n>>m && n!= -1 || m != -1)
        cout<<(zz(n,m) == 1 ? "YES" : "POOR Haha")<<endl;
    return 0;
}
```

---

# 2734 Quicksum

- 我真是废材，一到字符串的题就犯难........
- Problem Description

```
A checksum is an algorithm that scans a packet of data and returns a single number. The idea is that if the packet is changed, the checksum will also change, so checksums are often used for detecting transmission errors, validating document contents, and in many other situations where it is necessary to detect undesirable changes in data.

For this problem, you will implement a checksum algorithm called Quicksum. A Quicksum packet allows only uppercase letters and spaces. It always begins and ends with an uppercase letter. Otherwise, spaces and letters can occur in any combination, including consecutive spaces.

A Quicksum is the sum of the products of each character's position in the packet times the character's value. A space has a value of zero, while letters have a value equal to their position in the alphabet. So, A=1, B=2, etc., through Z=26. Here are example Quicksum calculations for the packets "ACM" and "MID CENTRAL":

ACM: 1*1 + 2*3 + 3*13 = 46MID CENTRAL: 1*13 + 2*9 + 3*4 + 4*0 + 5*3 + 6*5 + 7*14 + 8*20 + 9*18 + 10*1 + 11*12 = 650
```

- Input

```
The input consists of one or more packets followed by a line containing only # that signals the end of the input. Each packet is on a line by itself, does not begin or end with a space, and contains from 1 to 255 characters.
```

- Output

```
For each packet, output its Quicksum on a separate line in the outpu
```

- Sample Input

```
ACM
MID CENTRAL
REGIONAL PROGRAMMING CONTEST
ACN
A C M
ABC
BBC
#
```

- Sample Output

```
46
650
4690
49
75
14
15
```

- 这题真没什么好说的，就是字符串的输入，转换成字母在单词表中的顺序*序号
- 自我反省：c/c++基础语法学的不到位，导致函数不清楚功能，所以才会无从下手。
- gets() ：读取一串字符串，以回车结束

```c++
#include<iostream>
#include<stdio.h>
using namespace std;

int main(void)
{
    long long sum;
    char s[260];
    while(gets(s) && s[0] != '#')
    {
        sum = 0;
        for(int i = 0;s[i];i++)
        {
            if(s[i] != ' ')
                sum += (s[i] - 'A' + 1)*(i+1);
        }
        printf("%lld\n",sum);
    }
    return 0;
}

```

---

# 1170 Balloon Comes!

- Problem Description：

```
The contest starts now! How excited it is to see balloons floating around. You, one of the best programmers in HDU, can get a very beautiful balloon if only you have solved the very very very... easy problem.
Give you an operator (+,-,*, / --denoting addition, subtraction, multiplication, division respectively) and two positive integers, your task is to output the result. 
Is it very easy? 
Come on, guy! PLMM will send you a beautiful Balloon right now!
Good Luck!
```

- Input:

```
Input contains multiple test cases. The first line of the input is a single integer T (0<T<1000) which is the number of test cases. T test cases follow. Each test case contains a char C (+,-,*, /) and two integers A and B(0<A,B<10000).Of course, we all know that A and B are operands and C is an operator. 
```

- Sample Input:

```
Input contains multiple test cases. The first line of the input is a single integer T (0<T<1000) which is the number of test cases. T test cases follow. Each test case contains a char C (+,-,*, /) and two integers A and B(0<A,B<10000).Of course, we all know that A and B are operands and C is an operator. 
```

- Output:

```
For each case, print the operation result. The result should be rounded to 2 decimal places If and only if it is not an integer.
```

- Sample Input

```
4
+ 1 2
- 1 2
* 1 2
/ 1 2
```

- Sample Output

```
3
-1
2
0.50
```

- 唯独需要注意一点： 除法是需要判断的，如果要有小数，是需要输出2位小数的

```c
#include<iostream>
#include<stdio.h>
using namespace std;

int main(void)
{
    int n,a,b;
    float sum=0;
    char c;
    cin>>n;
    while(n--)
    {
        cin>>c>>a>>b;

        if(c == '+')
            cout<<a+b<<endl;
        else if(c == '-')
            cout<<a-b<<endl;
        else if(c == '*')
            cout<<a*b<<endl;
        else if(c == '/')
        {
            sum = (float)a/b;
            if(a%b == 0)
                printf("%d\n",a/b);
            else
                printf("%.2f\n",sum);
        }
    }
    return 0;
}

```

