[toc]

---

---

---

### **hashCode 与 equals (重要)**

- HashSet如何检查重复
- 两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？
- hashCode和equals方法的关系
- 你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？

#### hashCode()介绍

hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是
确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何
类都包含有hashCode()函数。

散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到
了散列码！（可以快速找到所需要的对象）

#### 为什么要有hashCode

**我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：**

当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals的次数，相应就大大提高了执行速度。

#### hashCode()与equals()的相关规定

- 如果两个对象相等，则hashcode一定也是相同的
- 如果两个对象相等，对两个对象分别调用equals方法都返回true
- 两个对象有相同的hashCode值，它们也不一定相等的

因此，equals方法被覆盖过，则hashCode方法也必须被覆盖。

hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对
象无论如何都不会相等（即使这两个对象指向相同的数据）

### 对象的相等与指向他们的引用相等，两者有什么不同？

对象的相等，比较的是内存中存放的内容是否相等，而引用相等，比较的是他们指向内存地址是否相等

### 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递

是值传递。java语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用的过程中被改变，但对对象引用的改变是不会影响到调用者。

