[toc]

---

---

---

### 1 反射简介？

#### 1.1 什么是反射？

反射（reflection）是Java程序开发语言的特征之一，它允许运行中的Java程序获取自身的信息，并且可以操作类或内部对象的内部属性。**通过反射机制，可以在运行时访问Java对象的属性、方法、构造方法等**。

#### 1.2 反射的应用场景

- **开发通用框架**：反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。
- **动态代理**： 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。
- **注解**：注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。如果没有反射机制，注解并不比注释更有用。
- **可扩展性功能**：应用程序可以通过使用完全限定名称创建可扩展性对象实例来使用外部的用户定义类。

#### 1.3 反射的缺点

- **性能开销** - 由于反射涉及动态解析的类型，因此无法执行某些 Java 虚拟机优化。因此，反射操作的性能要比非反射操作的性能要差，应该在性能敏感的应用程序中频繁调用的代码段中避免。
- **破坏封装性** - 反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。
- **内部曝光** - 由于反射允许代码执行在非反射代码中非法的操作，例如访问私有字段和方法，所以反射的使用可能会导致意想不到的副作用，这可能会导致代码功能失常并可能破坏可移植性。反射代码打破了抽象，因此可能会随着平台的升级而改变行为。

### 2 反射机制

#### 2.1 类的加载过程

类加载的完整过程如下：

1. 在编译时，Java编译器编译好`.java`文件后，在磁盘中产生`.class`文件。`.class`文件是二进制文件，内容只有JVM能够识别的机器码。
2. JVM中的类加载器读取字节码文件，取出二进制数据，加载到内存中，解析`.class`文件内的信息。类加载器会根据类的的全限定名来获取此类的二进制字节流；然后，将字节流所代表的的静态存储结构转化为方法区的运行时数据结构；接着，在内存中生成代表这个类的`java.lang.Class`对象。
3. 加载结束后，JVM开始进行链接阶段（验证，准备、初始化），经过一系列的操作，类的变量会被初始化。

#### 2.2 Class对象

要想使用反射，首先需要获得待操作的类所对应的 Class 对象。**Java 中，无论生成某个类的多少个对象，这些对象都会对应于同一个 Class 对象。这个 Class 对象是由 JVM 生成的，通过它能够获悉整个类的结构**。所以，`java.lang.Class` 可以视为所有反射 API 的入口点。

**反射的本质就是：在运行时，把 Java 类中的各种成分映射成一个个的 Java 对象**。**一个类有且只有一个`Class`对象。**

#### 2.3 方法的反射调用

方法的反射调用，就是`Method.invoke`方法。

```java
public final class Method extends Executable {
  ...
  public Object invoke(Object obj, Object... args) throws ... {
    ... // 权限检查
    MethodAccessor ma = methodAccessor;
    if (ma == null) {
      ma = acquireMethodAccessor();
    }
    return ma.invoke(obj, args);
  }
}
```

`Method.invoke` 方法实际上委派给 `MethodAccessor` 接口来处理。它有两个已有的具体实现：

- `NativeMethodAccessorImpl`：本地方法来实现反射调用
- `DelegatingMethodAccessorImpl`：委派模式来实现反射调用

每个 `Method` 实例的第一次反射调用都会生成一个委派实现（`DelegatingMethodAccessorImpl`），它所委派的具体实现便是一个本地实现（`NativeMethodAccessorImpl`）。本地实现非常容易理解。当进入了 Java 虚拟机内部之后，我们便拥有了 `Method` 实例所指向方法的具体地址。这时候，反射调用无非就是将传入的参数准备好，然后调用进入目标方法。

先调用 `DelegatingMethodAccessorImpl`；然后调用 `NativeMethodAccessorImpl`，最后调用实际方法。

为什么反射调用`DelegatingMethodAccessorImpl` 作为中间层，而不是直接交给本地实现？

其实，Java 的反射调用机制还设立了另一种动态生成字节码的实现（下称动态实现），直接使用 invoke 指令来调用目标方法。之所以采用委派实现，便是为了能够在本地实现以及动态实现中切换。动态实现和本地实现相比，其运行效率要快上 20 倍。这是因为动态实现无需经过 Java 到 C++ 再到 Java 的切换，但由于生成字节码十分耗时，仅调用一次的话，反而是本地实现要快上 3 到 4 倍。

考虑到许多反射调用仅会执行一次，Java 虚拟机设置了一个阈值 15（可以通过 `-Dsun.reflect.inflationThreshold` 来调整），当某个反射调用的调用次数在 15 之下时，采用本地实现；当达到 15 时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现，这个过程我们称之为 Inflation。